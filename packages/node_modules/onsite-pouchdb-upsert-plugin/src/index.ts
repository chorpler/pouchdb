// import * as PouchDB from 'pouchdb-core';

// declare const window:any;

export interface PouchDocRequired extends Object {
  _id:string;
  _rev?:string;
  [propName:string]:any;
}
export type PDBContent = PouchDocRequired;
// export type PDBContent = PouchDB.Core.Document<any>;
// export type PDBContent = PouchDB.Core.Document<PouchDocRequired>;
// export type PouchDoc           = PDBContent;
export type PouchDoc           = any;

export type CancelUpsert = '' | 0 | false | null | undefined; // falsey values
// `Partial<Core.Document<Content>>` seems more useful than
// `{} | Core.Document<Content>` since there isn't an easy way to narrow
// `{} | Core.Document<Content>` to `Core.Document<Content>`.
export type UpsertDiffCallback<Content extends {}> = (doc: Partial<Content>) => Content & Partial<PouchDB.Core.IdMeta> | CancelUpsert;

export interface UpsertResponse {
  id: PouchDB.Core.DocumentId;
  rev: PouchDB.Core.RevisionId;
  updated: boolean;
  ok?: boolean;
  deleted?:boolean;
  message?:string;
}

var maxUpsertCounter:number = 50;
var UpsertCounter:number = 0;
// this is essentially the "update sugar" function from daleharvey/pouchdb#1388
// the diffFun tells us what delta to apply to the doc.  it either returns
// the doc, or false if it doesn't need to do an update after all
async function upsertInner(db:PouchDB.Database, docId:PouchDB.Core.DocumentId, diffFun:UpsertDiffCallback<PouchDoc>):Promise<UpsertResponse> {
  try {
    let previouslyDeleted:boolean = false;
    UpsertCounter++;
    if(UpsertCounter > maxUpsertCounter) {
      let maxRetries:number = maxUpsertCounter || 50;
      let text:string = `Maximum upsert retries of ${maxRetries} exceeded`;
      let err:Error = new Error(text);
      UpsertCounter = 0;
      throw err;
    }
    if(typeof docId !== 'string') {
      // return Promise.reject(new Error('doc id is required'));
      let text:string = "doc id string is required";
      let err:Error = new Error(text);
      UpsertCounter = 0;
      throw err;
    }
    let doc:PouchDoc;
    try {
      doc = await db.get(docId);
    } catch(getError) {
      if(getError.status !== 404) {
        throw getError;
      } else if(getError.reason && getError.reason === "deleted") {
        previouslyDeleted = true;
        doc = [];
      } else {
        doc = {};
      }
    }
  
    // the user might incorrectly change the _rev with this upsert, so save it for posterity
    let docRev:string = doc && doc._rev ? doc._rev : "";
    let newDoc:PouchDoc = diffFun(doc);
  
    if(!newDoc) {
      // if the diffFun returns falsy, we short-circuit as
      // an optimization
      UpsertCounter = 0;
      return { updated: false, rev: docRev, id: docId };
    }
    if(previouslyDeleted  && newDoc._deleted) {
      return { updated: false, rev: "", id: docId, deleted: true, message: "cannot re-delete an existing deleted document" };
    }

    // users aren't allowed to modify these values, so
    // reset them to whatever currently exists in the database
    newDoc._id = docId;
    if(docRev) {
      newDoc._rev = docRev;
    } else {
      delete newDoc._rev;
    }
    let res:UpsertResponse = await tryAndPut(db, newDoc, diffFun);
    UpsertCounter = 0;
    return res;
  } catch(err) {
    throw err;
  }
}

async function tryAndPut(db:PouchDB.Database, doc:PouchDoc, diffFun:UpsertDiffCallback<PouchDoc>):Promise<UpsertResponse> {
  try {
    let putResponse:PouchDB.Core.Response = await db.put(doc);
    let res:UpsertResponse = {
      updated: true,
      rev: putResponse.rev,
      id: doc._id,
    };
    return res;
  } catch(err) {
    let PouchError:PouchDB.Core.Error = err;
    if(PouchError.status !== 409) {
      throw PouchError;
    } else {
      try {
        let res:UpsertResponse = await upsertInner(db, doc._id, diffFun);
        return res;
      } catch(UpsertError) {
        throw UpsertError;
      }
    }
  }
}

// declare namespace PouchDB {
//   interface Database<Content extends {} = {}> {
//     upsert
//   }
// }

// declare module PouchDB {
//   interface Database<Content extends {} = {}> {
//     upsert
//   }
// }

// let PouchDBWithUpsert:any = {};
// exports.upsert = function(docId:PouchDB.Core.DocumentId, diffFun:UpsertDiffCallback<PouchDoc>, cb?:Function):Promise<UpsertResponse> {
const upsert = async function(docId:PouchDB.Core.DocumentId, diffFun:UpsertDiffCallback<PouchDoc>):Promise<UpsertResponse> {
  try {
    let self:PouchDB.Database = this;
    let db:PouchDB.Database = self;
    // let resp:UpsertResponse = await upsertInner(db, docId, diffFun);
    let res:UpsertResponse = await upsertInner(db, docId, diffFun);
    return res;
  } catch(err) {
    throw err;
  }
};

// PouchDBWithUpsert.putIfNotExists = async function(docId:PouchDB.Core.DocumentId, doc:PouchDoc):Promise<UpsertResponse> {
// exports.putIfNotExists = async function(doc:PouchDoc):Promise<UpsertResponse> {
// exports.putIfNotExists = function(docId:PouchDB.Core.DocumentId, doc:PouchDoc, cb?:Function):Promise<UpsertResponse> {
const putIfNotExists = async function(docId:PouchDB.Core.DocumentId|PouchDoc, doc?:PouchDoc):Promise<UpsertResponse> {
  try {
    let self:PouchDB.Database = this;
    let db:PouchDB.Database = self;
    if(typeof docId !== 'string') {
      doc = docId;
      docId = doc._id;
    }
  
    let diffFun:UpsertDiffCallback<PouchDoc> = function(existingDoc:PouchDoc):PouchDoc|false {
      if(existingDoc._rev) {
        return false; // do nothing
      }
      // return putDoc;
      return doc;
    };
  
    let res:UpsertResponse = await upsertInner(db, docId, diffFun);
    return res;
  } catch(err) {
    throw err;
  }
};

/* istanbul ignore next */
// if(typeof window !== 'undefined') {
//   if((window as any).PouchDB) {
//     (window as any).PouchDB.plugin(PouchDBWithUpsert);
//   } else {
//     (window as any).PouchDB = PouchDB;
//     (window as any).PouchDB.plugin(PouchDBWithUpsert);
//   }
// }

export {upsert, putIfNotExists};
